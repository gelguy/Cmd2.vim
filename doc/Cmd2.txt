*Cmd2* 0.8.0 For Vim version 7.4

        ,ad8888ba,                              88  ad888888b,
       d8"'    `"8b                             88 d8"     "88
      d8'                                       88         a8P
      88            88,dPYba,,adPYba,   ,adPPYb,88      ,d8P"
      88            88P'   "88"    "8a a8"    `Y88    a8P"
      Y8,           88      88      88 8b       88  a8P'
       Y8a.    .a8P 88      88      88 "8a,   ,d88 d8"
        `"Y8888Y"'  88      88      88  `"8bbdP"Y8 88888888888

===========================================================================
CONTENTS                                                      *Cmd2Contents*

     1. Installation .................. |Cmd2Installation|
     2. Introduction .................. |Cmd2Introduction|
     3. Usage ......................... |Cmd2Usage|
     4. Mappings ...................... |Cmd2Mappings|
     5. Writing a custom function ..... |Cmd2WritingCustomFunction|
     6. Options ....................... |Cmd2Options|
     7. Cmd2Complete .................. |Cmd2Complete|
     8. Cmd2Suggest ................... |Cmd2Suggest|
     9. Customising search ............ |Cmd2CustomisingSearch|
    11. Optimising search ............. |Cmd2OptimisingSearch|
    10. FAQ ........................... |Cmd2FAQ|

===========================================================================
Section 1: Installation                                   *Cmd2Installation*

Use your favourite Plugin manager (e.g. Vim-Plug, Vundle, Pathogen)

The Github repository can be found at gelguy/Cmd2.vim

===========================================================================
Section 2: Introduction                                   *Cmd2Introduction*

Cmd2 is a Vim plugin which enhances Vim's |cmdline-mode|. It provides a
submode where mappings, shortcuts, custom functions and extensions can be
defined. A good comparison is |c_CTRL-R|, which prompts for a target
register and inserts its contents. Triggering Cmd2 will result in a similar
prompt, except you can use predefined or custom functions to handle the
input.

At a higher level, Cmd2 provides a framework to create extensions which
require cmdline input. One such extension is Cmd2Complete which provides
fuzzy completion for search in wildmenu style. The rendering of the UI and
handling of the input is handled by the framework, but can be further
customised - for example to create a CtrlP/Unite style menu instead.

===========================================================================
Section 3: Usage                                                 *Cmd2Usage*

Cmd2Suggest~

For Cmd2Suggest, add these mappings. The <F12> map can be changed to
something else that is not used.
>
  nmap : :<F12>     " for : mode (experimental)
  nmap / /<F12>

  cmap <F12> <Plug>(Cmd2Suggest)
<
A wildmenu-style menu will appear as you type your search. Press <Tab> and
<S-Tab> to move through the menu and <CR> to accept the suggestion.

Cmd2Suggest uses Cmd2Complete for getting its completions. See |Cmd2Suggest|.

Cmd2Complete~
If you only want fuzzy search completion, add this to your .vimrc.
>
    let g:Cmd2_options = {
          \ '_complete_ignorecase': 1,
          \ '_complete_uniq_ignorecase': 0,
          \ '_complete_fuzzy': 1,
          \ }

    cmap <expr> <Tab> Cmd2#ext#complete#InContext() ? "\<Plug>(Cmd2Complete)" : "\<Tab>"

    set wildcharm=<Tab>
<
To use, press /, enter a partial search and press <Tab>. This opens a
|wildmenu|-style line with the current matches. <Tab> and <S-Tab> to move
forward and backward through the list. Press any other key to continue typing,
or <Esc> to return to the original string.

See |Cmd2CustomisingSearch| for matching different patterns e.g.
CamelCase.

See |Cmd2Complete|.

Sample .vimrc settings~
For a quick start, copy and paste these into your .vimrc. The following
section will describe how to write a mapping and describe its components.
Note: the mapping of <C-S> is not universal as different terminals have
different sets of control keys.

>
    let g:Cmd2_cmd_mappings = {
      \ 'iw': {'command': 'iw', 'type': 'text', 'flags': 'Cpv'},
      \ 'ap': {'command': 'ap', 'type': 'line', 'flags': 'pv'},
      \ '^': {'command': '^', 'type': 'normal!', 'flags': 'r'},
      \ 'w': {'command': 'Cmd2#functions#Cword',
          \ 'type': 'function', 'flags': 'Cr'},
      \ }

    let g:Cmd2_options = {
      \ '_complete_ignorecase': 1,
      \ '_complete_uniq_ignorecase': 0,
      \ '_quicksearch_ignorecase': 1,
      \ '_complete_start_pattern': '\<\(\k\+\(_\|\#\)\)\?',
      \ '_complete_fuzzy': 1,
      \ }

    cmap <C-S> <Plug>Cmd2
    cmap <expr> <Tab> Cmd2#ext#complete#InContext() ? "\<Plug>(Cmd2Complete)" : "\<Tab>"

    set wildcharm=<Tab>
<

Let's assume <Plug>Cmd2 is mapped to <C-S>. Now suppose we enter the
cmdline with :. Pressing <C-S> will trigger Cmd2. Notice that the cursor
has changed to _ (default). This indicates that Cmd2 is active. We can
then refer to the mappings to see what functions we can perform. Try moving
to a function or paragraph, enter Cmd2 and press ap. This is a line
type, with command ap. In other words, this gets us the start and end
lines of the surrounding paragraph (see :h ap). The cursor is now back to
normal, indicating that Cmd2 is exited. To exit Cmd2 normally, just press
any unmapped key other than <Esc>.

Now move over a word and enter Cmd2 again, and press s. This enters
's//≡/g', with the cursor after the first /. We are out of Cmd2, so press
<C-S> and then w. This inserts the current word under the cursor. Notice
the cursor is still _ meaning we are still in Cmd2. This is because the
r flag is set. Press w two more times. The next word is inserted (two
times as there is space plus the next word). The ≡ is the snippet jump
target. To jump to the next target, in Cmd2, press <Tab>. <S-Tab> goes
to the opposite direction.

Finally, try searching for a string e.g. /f. Press <Tab>, and the fuzzy
search completion is triggered. It is in wildmenu style, <Tab> and
<S-Tab> select the next and previous item respectively. Notice that we did
not need to press <C-S> to enter Cmd2. This is as our mapping includes
<Plug>Cmd2 and then follows up with the CF mapping that activates the
complete function. Try again with mutliple characters.

Read the docs to understand how the types, flags and commands work. For more
advanced users, write your own custom functions to suit your needs.

===========================================================================
Section 4: Mappings                                           *Cmd2Mappings*
                                                       *g:Cmd2_cmd_mappings*

Creating a mapping~
To create a mapping, create the corresponding entry in the
|g:Cmd2_cmd_mappings| dictionary. The key cannot start with a digit as that
will be confused with the current count input. Mappings will be generated
when the plugin is initialised and cannot be changed without restarting Vim.

The dictionary key is the key combination to input. The dictionary entry is
composed of entries which are described as follows:

                                                         *Cmd2-mapping-type*

  type~
  How the command will be handled. There are 8 different types, literal,
  text, line, normal, normal!, snippet, remap andfunction. What they do
  and their corresponding commands will be described under the command
  section.

                                                      *Cmd2-mapping-command*

  command~
  The input to handle. Each type expects a different form of command, as
  follows:

    literal~
    The exact keys to feed to the cmdline. Useful for abbreviations. For
    example, help will result in the text help. Special keys are accepeted,
    such as "\<BS>" which will enter the backspace command at the point it
    is fed.

    text~
    A motion command/|text-obj|. Takes the motion command (or text-obj) and
    uses an |opfunc| to get the text inside the text-obj. For example, "iw"
    will result in the current inner-word under the cursor (an alternative
    to |<cword>|).

    line~
    A motion command/|text-obj|. Takes the motion command (or text-obj) and
    uses an |opfunc| to get the start and end lines of the text-obj. Useful
    for setting ranges when already in the cmdline. For example, "ap" will
    result in the start and end lines of the paragraph around the cursor.

    normal normal!~
    A |normal-mode| command. Executes the |:normal| or :normal! command.
    For example, "^" will move the cursor to the start of the sentence the
    cursor is currently at.

    * snippet~
    A snippet - text with jump targets which the users can jump to. The jump
    targets are defaulted to be |g:Cmd2_snippet_cursor_replace|. The default
    is ###. The jump targets are rendered as |g:Cmd2_snippet_cursor|. The
    default is ≡. The first target is automatically jumped to. For example,
    s/###/###/g results in the text s//≡/g with the cursor after the first
    /. The user can then use the Cmd2#functions#TabForward function to jump
    forward to the next target.

    remap~
    A Cmd2 mapping key. Triggers the corresponding entry in the mappings.
    Remap depth is limited by |g:Cmd2_max_remap_depth|. Remaps are useful
    this skips the feeding of keys using |getchar()|. Some mappings might be
    long such as \<Plug>Cmd2TabForwards and the remap reduces the delay when
    using a |cmap|.

    function~
    A string or a |Funcref|. If a string, needs to be the name of a
    function. The function is called. The only argument passed to it is the
    current ccount, depending on the c flag. More details about writing
    custom functions can be found under the section.

                                                        *Cmd2-mapping-flags*

  flags~
  Setting these flags will determine the behaviour before, during and after
  an action is performed.

    c C~
    Similar to v:count and v:count1. Setting c will pass the current count
    passed to Cmd2. When there is no count, it is defaulted to 0. With C,
    the count is default as 1. When both flags are set, C will have the
    higher priority. Note that of the predefined functions, only normal,
    normal! and literal will accept count.

    r~
    After completing the action, the keys <Plug>Cmd2 are fed, triggering
    Cmd2 again. This is convenient for functions which do not want to exit
    Cmd2, e.g. manipulating the cmd cursor position with
    Cmd2#functions#End. |g:Cmd2_reenter_key| can be defined which will
    feed the keys after reentering Cmd2.

    p~
    Restore the buffer cursor position to where it was before Cmd2 was
    triggered. Useful for functions which might change the cursor position,
    such as line commands.

    v~
    Restore the visual selection when Cmd2 was triggered, if there was one.
    Not all functions might want to do this, as the cursor position will be
    moved to where the cursor was in the visual selection.


===========================================================================
Section 5: Writing a custom function             *Cmd2WritingCustomFunction*

The custom function takes 0 or 1 arguments, depending on whether the c flag
is set. In practice, it is best to use a variadic function, which can accept
any number of arguments.
>
  function! Cmd2#functions#Cword(...)
    let ccount = get(a:000, 0, 1)
<

If the function is defined locally i.e. in a script, it can be passed to
mapping dictionary using a |Funcref|.

The contents of the cmdline and the position of the cursor can be
manipulated using the following exposed global variables. g:Cmd2_pending_cmd
is a length-2 list, with the first element containing the cmdline substring
before the cursor, and the second after the cursor. g:Cmd2_output is the
string which will be placed after the cursor.

For example, if the g:Cmd2_pending_cmd is ['foo', 'bar'] and g:Cmd2_output
is baz, then the final state of the cmdline will be foobazbar with the
cursor after z.

To manipulate the cursor position, g:Cmd2_pending_cmd will need to be
modified accordingly.

Example:
>
  function! Cmd2#functions#CopySearch(...)
    let cmd = g:Cmd2_pending_cmd[0] . g:Cmd2_pending_cmd[1]
    let matchstr = matchlist(cmd, '\vs/(.{-})/')
    if !empty(matchstr[1])
      let g:Cmd2_output = matchstr[1]
    endif
  endfunction
<
This function leaves g:Cmd2_pending_cmd unmodified, and outputs the keyword
between s/keyword/.

===========================================================================
Section 6: Options                                             *Cmd2Options*
                                                            *g:Cmd2_options*

Cmd2 options can be set by defining the |g:Cmd2_options| dictionary in your
.vimrc.

Below are the possible options, their default setting and description.

  buffer_cursor_hl~
  *g:Cmd2_buffer_cursor_hl*
  default: Cmd2#init#BufferCursorHl()

  The |hlgroup| to use to highlight the current cursor position in the
  buffer. Note that when Vim enters |cmdline-mode|, the cursor disappears
  from the buffer as it moves to the cmdline. Cmd2#init#BufferCursorHl() is
  used to create the Cmd2Cursor hlgroup, which links to Cursor if the
  hlgroup exists or reverse otherwise.

  buffer_cursor_show~
  *g:Cmd2_buffer_cursor_show*
  default: 1

  Boolean to toggle whether to highlight the current cursor position in the
  buffer.

  cursor_blink~
  *g:Cmd2_cursor_blink*
  default: 1

  Boolean to toggle whether the cursor on the cmdline blinks. Since the
  rendering of the cmdline is done with `echo`, it may result in flickering
  depending on the refresh rate of VIM itself. Turning off the
  `cursor_blink` only redraw the cmdline once per input, resulting in less
  to no flickering.

  cursor_blinkwait~
  *g:Cmd2_cursor_blinkwait*
  default: 700

  cursor_blinkon~
  *g:Cmd2_cursor_blinkon*
  default: 400

  cursor_blinkoff~
  *g:Cmd2_cursor_blinkoff*
  default: 250

  The behaviour of how the cmdline cursor blinks. cursor_blinkwait is the
  delay before the cursor starts blinking, cursor_blinkon is the time the
  cursor is shown and cursor_blinkoff is the time the cursor is not shown.
  The times are in msec. In gVim, the default behaviour of the cursor out of
  Cmd2 can be found using |&guicursor|. See |guicursor|.

  cursor_hl~
  *g:Cmd2_cursor_hl*
  default: Cmd2#init#CursorHl()

  The |hlgroup| to use to highlight the cmdline cursor when it is shown.
  Cmd2#init#BufferCursorHl() is used to create the Cmd2Cursor hlgroup, which
  links to Cursor if the hlgroup exists or reverse otherwise.

  cursor_text~
  *g:Cmd2_cursor_text*
  default: '_'

  The text of the cmdline cursor. Can be |multibyte|.

  max_remap_depth~
  *g:Cmd2_max_remap_depth*
  default: 20

  The maximum number of remaps. See remap under |Cmd2-mapping-command|.

  loop_sleep~
  *g:Cmd2_loop_sleep*
  default: 20

  The time to |sleep| in between each input/render loop. The time is in
  msec. A lower time will result in more responsiveness. 0 is accepted.
  Changing the sleep time can also affect the flickering of the cmdline (may
  be better or worse, the effect is uncertain).

  loop_func~
  *g:Cmd2_loop_func*
  default: 'Cmd2#loop#Init'

  A string or a |Funcref|. If a string, needs to be the name of a function.
  Used in writing extensions.

  preload~
  *g:Cmd2_preload*
  default: 0

  Whether to preload the plugin instead of waiting for |autoload|ing.
  Preloading will take up more time during startup but autoloading will
  result in a delay when using Cmd2 for the first time.

  snippet_cursor~
  *g:Cmd2_snippet_cursor*
  default: '≡'

  The string to show when rendering the snippet jump target. See snippet
  under |Cmd2-mapping-command|.

  snippet_cursor_hl~
  *g:Cmd2_snippet_cursor_hl*
  default: 'Title'

  The |hlgroup| to use to highlight the snippet jump targets.

  snippet_cursor_replace~
  *g:Cmd2_snippet_cursor_replace*
  default: '###'

  The string to use when defining jump targets in a snippet. See snippet
  under |Cmd2-mapping-command|.

  timeoutlen~
  *g:Cmd2_timeoutlen*
  default: |&timeoutlen|

  The time in milliseconds that is waited for the keyed input to complete.
  The timeout starts when the first non-digit key is entered.

  menu_selected_hl~
  *g:Cmd2_menu_selected_hl*
  default: 'WildMenu'

  The |hlgroup| to use to highlight the selected item when menu is
  activated.

  menu_hl~
  *g:Cmd2_menu_hl*
  default: 'StatusLine'

  The |hlgroup| to use to highlight the unselected items and padding when
  menu is activated.

  menu_next~
  *g:Cmd2_menu_next*
  default: '>'

  The string used to indicate there is a next page in the menu when menu is
  activated. Can be |multibyte|.

  menu_previous~
  *g:Cmd2_menu_previous*
  default: '<'

  The string used to indicate there is a previous page in the menu when menu
  is activated. Can be |multibyte|.

  menu_more~
  *g:Cmd2_menu_more*
  default: '…'

  The string used to append to a menu item if it is truncated because it is
  too long. Can be |multibyte|.

  menu_separator~
  *g:Cmd2_menu_separator*
  default: ' '

  The string used to appended between each menu item. Can be |multibyte|.

  menu_separator_hl~
  *g:Cmd2_menu_separator_hl*
  default: 'StatusLine'

  The hlgroup to use to highlight the separators.

===========================================================================
Section 7: Cmd2Complete                                       *Cmd2Complete*

Cmd2Complete is an extension built on Cmd2. It provides fuzzy completion for
search in |wildmenu| style. It can be mapped as a function using
Cmd2#ext#complete#Main. Once activated, the next and previous keys will
cycle through the candidates, listed in wildmenu style.

Options are defined in the same |g:Cmd2_options| dictionary. As an
extension, the options are prepended with `_`. The options are lsited below.

  _complete_ignorecase~
  *g:Cmd2__complete_ignorecase*
  default: 0

  Boolean to toggle whether to ignore case when looking for matches.

  _complete_uniq_ignorecase~
  *g:Cmd2__complete_uniq_ignorecase*
  default: 1

  Boolean to toggle whether to ignore case when removing repeat matches.
  This is different from ignoring case while searching as we might want to
  keep the different casings of the same word as options. This value does
  not matter if |g:Cmd2__complete_ignorecase| is not set.

  _complete_pattern_func~
  *g:Cmd2__complete_pattern_func*
  default: 'Cmd2#ext#complete#CreatePattern',

  A string or a |Funcref|. If a string, needs to be the name of a function.
  The function to call to create the pattern. To be used to when a static
  regex is not enough to create the pattern. The function is passed 1
  argument, the search string that is to be matched. The function can use
  the set start, middle and end pattern to create the final pattern. See
  |Cmd2CustomisingSearch|.

  _complete_start_pattern~
  *g:Cmd2__complete_start_pattern*
  default: '\<'

  A |pattern| to use while searching. Note: |\V| or "very nomagic" is on so
  the characters have to be escaped accordingly. The pattern is prepended at
  the start of the search string.

  _complete_middle_pattern~
  *g:Cmd2__complete_middle_pattern*
  default: '\k\*'

  A |pattern| to use while searching. Note: |\V| or "very nomagic" is on so
  the characters have to be escaped accordingly. This pattern is only used
  when |g:Cmd2__complete_fuzzy| is on. The pattern is added in between each
  character of the search string. Note that since this pattern will be added
  a lot of times when the string is long, it is recommended to use |\%(|\)
  for groupings in the pattern.

  _complete_end_pattern~
  *g:Cmd2__complete_end_pattern*
  default: '\k\*'

  A |pattern| to use while searching. Note: |\V| or "very nomagic" is on so
  the characters have to be escaped accordingly. The pattern is appended at
  the end of the search string.

  _complete_fuzzy~
  *g:Cmd2__complete_fuzzy*
  default: 1

  Boolean to set if fuzzy search is on.

  _complete_next~
  *g:Cmd2__complete_next*
  default: "\<Tab>"

  Key to enter to go to the next item in the menu.

  _complete_previous~
  *g:Cmd2__complete_previous*
  default: "\<S-Tab>"

  Key to enter to go to the previous item in the menu.

  _complete_exit~
  *g:Cmd2__complete_exit*
  default: "\<Esc>"

  Key to enter to cancel the matching and exit to the cmdline. This returns
  the cmdline to its original state. Any key that is not next, previous or
  exit will accept the match and enter the corresponding key. Therefore if
  this is set to "\<Esc>" then <Esc> has to be entered twice to exit into
  normal mode. One <Esc> will return to the cmdline.

  _complete_loading_text~
  *g:Cmd2__complete_loading_text*
  default: ""

  String which will replace the cursor when Cmd2Complete is generating the
  candidates. As the generation of candidates may take a while for large
  files, this can be used to show that Cmd2 is busy. Setting to an empty
  string will toggle this feature off.

  _complete_loading_hl'~
  *g:Cmd2__complete_loading_hl*
  default: ""

  The |hlgroup| to use to highlight the loading text when
  |g:Cmd2__complete_loading_text| is set.

  _complete_generate~
  *g:Cmd2__complete_generate*
  default: 'Cmd2#ext#complete#GenerateCandidates'

  A string or a |Funcref|. If a string, needs to be the name of a function.
  The function is called to generate the list of candidates. The function is
  passed 1 argument, which is the the cmdline. The function will have access
  to the global variables such as g:cmd2_pending_cmd if the argument is not
  enough. The list should be a list of strings, in the order they would
  appear in the menu. This means searching, sorting, uniq-ng and ranking
  should be done.

  _complete_string_pattern~
  *g:Cmd2__complete_string_pattern*
  default: '\v\k*$'

  A |pattern|. The regex pattern used to get the substring of the cmdline to
  match with. Unlike the other patterns, the |magic| setting is not set. The
  default takes the last sequence of keywords before the cursor. To include
  characters behind the cursor, see |g:Cmd2__complete_get_string|.

  EXPERIMENTAL: _complete_get_string~
  *g:Cmd2__complete_get_string*
  default: 'Cmd2#ext#complete#GetString'

  A string or a |Funcref|. If a string, needs to be the name of a function.
  The function is called to generate the string to match from the cmdline.
  It is passed no arguments. It has access to s:old_cmd, which is a copy of
  the g:Cmd2_pending_cmd when Cmd2Complete is started. This needs to be a
  copy as g:Cmd2_pending_cmd will be changed. This should be used to create
  match strings such as those which include substrings behind the current
  cursor position. See |Cmd2CustomisingSearch|.

  _complete_conceal_patterns~
  *g:Cmd2__complete_conceal_patterns*
  default: {}

  A dictionary with regexes as keys. Conceals the regexes matched with the
  replacement when shown in the menu. Although it looks different in the menu,
  the text entered will still be the unconcealed text. For example,
  {'function': 'f'} will conceal 'function' with 'f'.

  _complete_conceal_func~
  *g:Cmd2__complete_conceal_func*
  default: 'Cmd2#ext#complete#Conceal'

  A string or a Funcref. If a string, needs to be the name of a function. The
  function to be called to create the concealed text of the candidates. It is
  passed the list of strings which are the candidates. The function is
  expected to return a list of dictionaries in the form {'text': ...,
  'value:' ...} where text is the concealed text to show and value is the
  true value to insert.

  EXPERIMENTAL: _complete_incsearch~
  *g:Cmd2__complete_incsearch*
  default: 0

  Boolean to set if incsearch is on. The cursor will move to the position of
  the current menu candidate, like |incsearch|. Best used with `set incsearch`
  to highlight the current candidate.

  _complete_mru_length~
  *g:Cmd2__complete_mru_length*
  default: 0

  Length of most-recently-used list to maintain. Items from the MRU list will
  have higher priority than others when sorting. Setting to 0 will stop the
  MRU list from updating. This means u can pre-populate the
  *g:Cmd2__search_mru* and those words will have the highest priority.

  _complete_sort_func~
  *g:Cmd2__complete_sort_func*
  default: 'lexographic'

  A string or a Funcref. If a string, can take the values of 'lexographic' or
  'string_score'. Otherwise needs to be the name of a function. The function
  passed to the |sort()| function when creating candidates. 'string_score' is
  slow.

  _complete_show_original~
  *g:Cmd2__complete_show_original*
  default: 1

  Boolean to set if the original search is inserted as the first element of
  the menu.

===========================================================================
Section 8: Cmd2Suggest                                         *Cmd2Suggest*

Cmd2Suggest is an extension built on Cmd2, using Cmd2Complete. It is similar
to Cmd2Complete, except that instead of triggering when a specific key is
pressed, the menu is updated as you type. This has 2 modes, one with |:| and
one with |/|. |:| mode is experimental. For |/| mode, the completions are
gathered from |g:Cmd2__complete_generate|. This requires overriding of default
|:| and |/|, so it may not work perfectly with other plugins and some default
functionality may be missing.

Please see |Cmd2OptimisingSearch| to reduce the latency between key presses.


                                                           *Cmd2SuggestKeys*

<Tab> or <C-N>   : move to the next menu item
<S-Tab> or <C-P> : move to the previous menu item
<CR>             : complete the current input (see |g:Cmd2__suggest_enter_suggest|
                   and |g:Cmd2__suggest_enter_search_complete|)
<S-CR>           : enter the current input without completion
<Down>           : in |:| mode, with directories, accept the current
                 : completion and trigger suggestions for the new completion
                 : (like |wildmenu|).
<Up>             : in |:| mode, with directories, go to the parent directory
                 : (like |wildmenu|).
<Esc>            : either cancel current completion or exit the commandline,
                 : depending on |g:Cmd2__suggest_esc_menu|.

As a clarification, "suggest" refers to the text appearing after the cursor
when the head of the first menu item matches exactly the current input.
"complete" refers to the completion done by moving through the menu.
"suggestions" refers to both the menu and the autosuggest text.

Options are defined in the same |g:Cmd2_options| dictionary. As an
extension, the options are prepended with `_`. The options are lsited below.

  _suggest_suggest_hl~
  *g:Cmd2__suggest_suggest_hl*
  default: 'Visual'

  The |hlgroup| to use to highlight the autosuggest text. Autosuggest text
  will only appear when the head of the first item matches exactly with the
  current input.

  _suggest_complete_hl~
  *g:Cmd2__suggest_complete_hl*
  default: 'Statement'

  The |hlgroup| to use to highlight the completion text, when moving through
  the menu.

  _suggest_show_suggest~
  *g:Cmd2__suggest_show_suggest*
  default: 1

  Boolean when true, shows autosuggest.

  _suggest_min_length~
  *g:Cmd2__suggest_min_length*
  default: 0

  Number to set for the minimum length to start triggering suggestions.

  _suggest_space_trigger~
  *g:Cmd2__suggest_space_trigger*
  default: 0

  For |:| mode. Boolean for whether to trigger suggestions when the most
  recent character is ' '.

  _suggest_no_trigger~
  *g:Cmd2__suggest_no_trigger*
  default: [
    \ '\m^ec\%[ho] ',
    \ '\m^let .*=',
    \ '\m\*\*',
    \ ]

  For |:| mode. A list of |patterns|. These patterns will not trigger
  suggestions. Suggestions can be forced to trigger by pressing <Tab> or
  <S-Tab>. These are needed as some commands take very long to gather
  candidates (e.g. |echo| takes any function hence all the functions will have
  to be populated).

  _suggest_middle_trigger~
  *g:Cmd2__suggest_middle_trigger*
  default: 0

  Boolean when true, triggers suggestions when the cursor is not at the end of
  the current input.

  _suggest_jump_complete~
  *g:Cmd2__suggest_jump_complete*
  default: 0

  For |:| mode. Boolean if true, performs completion and triggers the
  suggestions for the new completion if there is only one completion for the
  current item. Used when dealing with directories (e.g. 'cd dir').

  _suggest_esc_menu~
  *g:Cmd2__suggest_esc_menu*
  default: 0

  Boolean for whether <Esc> cancels current completion if the menu is active.
  Otherwise <Esc> exits from commandline mode.

  _suggest_enter_suggest~
  *g:Cmd2__suggest_enter_suggest*
  default: 1

  For |:| mode. Number if 1, <CR> is pressed, the current autosuggest if any
  will be appended to the input only if there is only one completion. If 2,
  always appends. If 0, never appends.

  _suggest_bs_suggest~
  *g:Cmd2__suggest_bs_suggest*
  default: 0

  Boolean when true, inputting <BS> deletes the current autosuggest if any.
  When false, the autosuggest is removed along with the character behind the
  cursor (like normal <BS>).

  _suggest_enter_search_complete~
  *g:Cmd2__suggest_enter_search_complete*
  default: 0

  For |/| mode. Number if 1, <CR> is pressed, the first completion if any
  will replace the input only if there is only one completion. If 2,
  always replaces. If 0, never replaces.

    _suggest_tab_longest~
  *g:Cmd2__suggest_tab_longest*
  default: 0

  For |:| mode. Boolean when true, <Tab> will insert the longest common
  starting text of the completions, if any. If there are no completions,
  <Tab> will proceed as normal.

  _suggest_search_profile~
  *g:Cmd2__suggest_search_profile*
  default: 0

  For |/| mode. Boolean when true, will profile the time taken to gather the
  candidates for the menu. The results will be stored in *g:Cmd2_profile*
  which is a list of Dictionaries, with the format {string: time(msecs)}.
  Useful when checking how fast custom |g:Cmd2__complete_generate| functions
  are.

===========================================================================
Section 9: Customising search             *Cmd2CustomisingSearch*

Customising fuzzy search~

To customise the fuzzy search, |g:Cmd2__complete_start_pattern|,
|g:Cmd2__complete_middle_pattern| and |g:Cmd2__complete_end_pattern| have to
be set accordingly.

The default options will match strings of keywords which contain a
subsequence matching the search string.

To match strings beginning with |g:|, |s:|, etc., we can set
|g:Cmd2__complete_start_pattern| to '\<\%(\[agls]\:\)\?\k\*'.

To match substrings with the first match is not necessarily the start of the
string, we can set |g:Cmd2__complete_start_pattern| to '\<\(\k\|[_\-#]\)\*'.
This will match 'Cmd2#functions#Back' with Back, and also with ack.

To match substrings with first match at the start or after a delimiter, we
can set |g:Cmd2__complete_start_pattern| to '\<\(\k\*\[_\-#]\)\?'. This will
match 'Cmd2#functions#Back' with Back, and not with ack.

To do a stricter match such that each character in the search either follows
a previous match or begins after a delimiter, we can set
|g:Cmd2__complete_middle_pattern| to '\%(\k\*\[_\-#]\)\?'. This will match
'Cmd2#functions#TabForwards' with CTab but not CTb.

In some cases, a static regex based on the start, middle and end patterns
may not be sufficient. One example is CamelCase delimiters. We want a
stricter match as in the previous example, but also to treat each
CamelCase-d character as a delimiter. This is trivial when ignorecase is
off. However, with ignorecase |\c|, the entire regex is treated as
case-insensitive. This means we cannot use the default
g:Cmd2__complete_pattern_func. We have to create one which provides the
possible CamelCase-d characters case-sensitivity. This is done as follows:

>
  function! s:CustomFuzzySearch(string)
    let pattern = ""
    let ignore_case = g:Cmd2__complete_ignorecase ? '\c' : ''
    let char = matchstr(a:string, ".", byteidx(a:string, 0))
    let pattern = '\V' . ignore_case
    let pattern .= '\<\%(\[agls]\:\)\?'
    let pattern .= '\%(\%(\k\*\[_\-#]\)\?' . char
    let pattern .= '\|\k\*\%(' . char . '\&\L\)\)'
    if g:Cmd2__complete_fuzzy
      let result = ''
      let i = 1
      while i < len(a:string)
        let char = matchstr(a:string, ".", byteidx(a:string, i))
        let result .= '\%(' . '\%(\k\*\[_\-#]\)\?' . char . '\|'
        let result .= '\k\*\%(' . char . '\&\L\)' . '\)'
        let i += len(char)
      endwhile
      let pattern .= result
    else
      let pattern .= a:string
    endif
    let pattern .= g:Cmd2__complete_end_pattern
    return pattern
  endfunction
<

Note the use of \({char}\&\L\). |\L| is a character class, and hence not
affected by the \c flag. This will match s:CustomFuzzySearch with cfs.

To customise the substring of the cmdline to match, use
|g:Cmd2__complete_string_pattern|. The default takes the last sequence of
keywords before the cursor. However, we might want to include '.' as a
keyword to match so we can do 'obj.value'. To do this, we change
string_pattern to '\v(\.|\k)*$'. This way we can type 's.' to match
'state.*'.

|g:Cmd2__complete_string_pattern| only matches from before the cursor. To
get matches that include patterns from after the cursor, use
|g:Cmd2__complete_get_string|.

===========================================================================
Section 10: Optimising search                         *Cmd2OptimisingSearch*

Optimising fuzzy search~

It is important to optimise |g:Cmd2__complete_generate| as it is called every
keypress. If the search takes too long, there will be a high latency before
the next keypress is registered, leading to the feeling of lag. The default
generate function uses VimScript, and will start to feel laggy for large
files i.e. >1000 lines.

The time taken to gather the candidates can be found by setting
|g:Cmd2__suggest_search_profile|. The target should be below 50ms for each
keypress.

There are various ways to optimise.

Using Python or Ruby~

Using Python or Ruby will result in much faster regex matching and sorting.
Python and Ruby use PCRE, which is very easy to translate from Vim's regex.

Mainly:
'\<'   becomes '\b'
'\%()' becomes '(?:)'

Example of a fuzzy pattern in PCRE:
>
  function! FuzzyPattern(string)
    let k = '(?:\w|[_\-#.])'      " keyword
    let result = g:Cmd2__complete_ignorecase ? '(?i)' : ''
    let result .= '\b'
    " this allows the fuzzy search to start in the middle of a string
    " but results in a noticeable slowdown for large files
    " comment out the next line to stop this
    let result .= '(?:[agls]:|_)?' . k . '*'
    let i = 0
    while i < len(substitute(a:string, '.', 'x', 'g'))
      let char = matchstr(a:string, ".", byteidx(a:string, i))
      if char == '\'
        if i == len(substitute(a:string, '.', 'x', 'g'))
          let char .= '\\\'
        else
          let char .= matchstr(a:string, ".", byteidx(a:string, i+1))
        endif
        let offset = 1
      else
        let offset = 0
      endif
      let result .= char
      let result .= k . '*'
      let i += 1 + offset
    endwhile
    return result
  endfunction
<
Example of search using Python:

In g:Cmd2_options, set '_complete_generate' to 'PythonSearch'.
>
  function! PythonSearch(cmd)
    let escape_cmd = escape(a:cmd, '|$*.[]()')
    let pattern = FuzzyPattern(escape_cmd)
<
python << EOF
import re

buffer = vim.current.buffer
pattern = vim.eval('pattern')
string = vim.eval('g:Cmd2_pending_cmd[0]')
result = re.findall(pattern, '\n'.join(buffer[:]))
uniq = list(set(result))
filtered = filter(lambda x: len(x) > 0, uniq)
mru = vim.eval('g:Cmd2_search_mru_hash')
size = len(mru)
string = vim.eval('a:cmd')
sort = sorted(filtered, key=lambda x: [int(mru.get(x, size)), x.lower()])
vim.command('let results = %s' % sort)
EOF
    return results
  endfunction

Using re2~

For even larger files i.e. 10k lines, the default regex engine of Python and
Ruby will start to feel slow. re2 is an extremely fast regex library which
uses a subset of PCRE. The above FuzzyPattern will work fine in re2.

For Python users on Windows, the .whl file can be found at
http://www.lfd.uci.edu/~gohlke/pythonlibs/

For Python users on Linux, use easy_install.

All that has to be changed is

import re

to

try:
    import re2 as re
except ImportError:
    import re

Using neocomplete source~

For even larger files where re2 feels slow, the neocomplete buffer source can
be used.

>
  function! s:PythonCache(cmd)
    if !get(b:, 'cache_init', 0)
      call neocomplete#init#_sources(['buffer'])
      call neocomplete#available_sources().buffer.hooks.on_init(0)
      let b:cache_init = 1
    endif
    let candidates = neocomplete#available_sources().buffer.gather_candidates('')
    let escape_cmd = escape(a:cmd, '|$^*.()[]')
    let pattern = s:PythonDelimited(escape_cmd)

python << EOF
try:
    import re2 as re
except ImportError:
    import re

candidates = vim.eval('candidates')
pattern = vim.eval('pattern')
result = [ x for x in candidates if re.match(pattern, x) ]
mru = vim.eval('g:Cmd2_search_mru_hash')
size = len(mru)
string = vim.eval('a:cmd')
sort = sorted(result, key=lambda x: [int(mru.get(x, size)), x.lower()])
vim.command('let results = %s' % sort)
EOF
    return results
  endfunction

Use Cmd2Complete~

If the above optimisations are still too slow, |Cmd2Complete| might be more
viable, as completions are only generated on demand.

===========================================================================
Section 10: FAQ                                                    *Cmd2FAQ*

Choosing a cmap key~

Different terminals have different Control keys hence the \<Plug>Cmd2
mapping may not be available in all terminals. If all else fails, using one
of the Vim's default cmdline mappings will help solve the issue. See :h
|c_CTRL-V| and onwards.

Flickering~

As Cmd2 renders the cmdline and menu using echo, there might be flickering.
Changing the |g:Cmd2_loop_sleep| variable will have different effects
depending on the terminal used. In general, a lower value should result in
less flickering. Otherwise, setting |g:Cmd2_cursor_blink| to 0 will turn off
the cursor blink, which will result in no re-rendering and hence no
flickering.

Slow fuzzy matching~

The default fuzzy matcher uses Vim's inbuilt |search()| and |match()|
functions to generate the list of candidates. The candidates are then sorted
and uniq-ed with an unoptimised algorithm. This might result in a noticeable
delay when dealing with large files. A way to fix this is to use set
|g:Cmd2_complete_generate| to a custom function which is faster. Some
possible ways to do this is to use Python or Lua, or use existing sources
such as from neocomplete. See |Cmd2OptimisingSearch|.

Putty mouse flickering~

In Putty, the cursor may flicker between insert text mode and pointer mode
when Cmd2 is triggered. This is due to the cursor changing into pointer mode
when a sleep command is given to Vim. To prevent this, change
|g:Cmd2_loop_sleep| to 0. This will stop Cmd2 from sleeping in between
loops but may affect the cmdline flickering.

Esc key has to be pressed twice~

  This is fixed by Vim patch 7.4.306. Please update Vim to the latest version.
  Alternatively, you can map another key to Esc using

>
  cnoremap <key> <nop>
<

vim:tw=78:sw=4:ft=help:
